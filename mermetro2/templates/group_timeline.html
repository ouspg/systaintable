<!DOCTYPE html>
<html>
<head>
    <title>Mermetro2</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.3/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            maxTextSize: 10000000000,
            maxEdges: 500000,
            startOnLoad: false,
            flowchart: { htmlLabels: true, curve: 'linear' },
            securityLevel: 'loose'
        });
        let currentTimeline = '';
        let selectedGroup = '{{ selected_group }}';
        let chartDirection = 'TD';
        
        let modal, modalTitle, modalContent;
        
        let excludedEntries = [];
        
        let currentMetromap = '';

        function createTable(entries, title, tooltipText, technicalClass = '') {
            return `
                <div class="entries-section">
                    <h4>${title} <span class="tooltip" title="${tooltipText}">ℹ</span></h4>
                    <div class="table-container">
                        <table class="entries-table${technicalClass ? ' ' + technicalClass : ''}">
                            <thead><tr><th>Line</th><th>Time</th><th>Type</th><th>Value</th></tr></thead>
                            <tbody>
                                ${entries.map(entry => `
                                    <tr>
                                        <td>${entry.line}</td>
                                        <td>${entry.timestamp}</td>
                                        <td>${entry.type}</td>
                                        <td class="value-cell" title="${entry.value}">${entry.value}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function createGroupSection(title, entries) {
            return `
                <h4>${title}</h4>
                ${entries && entries.length > 0 ? `
                    <div class="group-section">
                        <ul class="entry-list">
                            ${entries.map(entry => {
                                let value, type;
                                if (entry && typeof entry === 'object') {
                                    value = entry.value !== undefined ? entry.value : entry;
                                    type = entry.type || '';
                                } else {
                                    value = entry;
                                    type = '';
                                }
                                const isUrl = typeof value === 'string' && value.startsWith('http');
                                const valueHtml = isUrl ? `<span class="url-value" title="${value}">${value}</span>` : `${value}`;
                                return `<li>• ${valueHtml}${type ? ` <span class="entry-type">(${type})</span>` : ''}</li>`;
                            }).join('')}
                        </ul>
                    </div>
                ` : '<p class="no-entries">N/A</p>'}
            `;
        }

        function createDetailsTable(entries, title, tooltipText) {
            return `
                <div class="entries-section">
                    <h4>${title} <span class="tooltip" title="${tooltipText}">ℹ</span></h4>
                    <div class="table-container">
                        <table class="entries-table">
                            <thead><tr><th>Line</th><th>Timestamp</th><th>Type</th><th>Value</th></tr></thead>
                            <tbody>
                                ${entries.map(entry => `
                                    <tr>
                                        <td>${entry.line || ''}</td>
                                        <td>${entry.timestamp || ''}</td>
                                        <td>${entry.type || ''}</td>
                                        <td class="value-cell" title="${entry.value || ''}">${entry.value || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        window.showNodeDetails = function(nodeId) {
            const cleanNodeId = nodeId.startsWith('flowchart-') ? nodeId.substring(10) : nodeId;
            fetch(`/api/node-details/${cleanNodeId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Node "${cleanNodeId}" not found`);
                        return;
                    }
                    showNodeOrGroupModal(data);
                })
                .catch(error => alert(`Failed to fetch details: ${error.message}`));
        }

        function showNodeOrGroupModal(nodeData) {
            let content = '<div class="node-info">';
            if (nodeData.type === 'GroupMerged') {
                content += '<h4>Merged groups</h4>';
                if (Array.isArray(nodeData.merged_groups)) {
                    nodeData.merged_groups.forEach((group, idx) => {
                        content += `<div class="group-section"><b>Group ${idx + 1}:</b><br/>`;
                        if (Array.isArray(group.entries) && group.entries.length > 0) {
                            content += '<ul class="entry-list">';
                            group.entries.forEach(entry => {
                                content += `<li>• ${entry.value} <span class="entry-type">(${entry.type})</span></li>`;
                            });
                            content += '</ul>';
                        } else {
                            content += '<p class="no-entries">N/A</p>';
                        }
                        content += '</div>';
                    });
                } else {
                    content += '<p>N/A</p>';
                }
                const allEntries = Array.isArray(nodeData.entries) ? nodeData.entries : [];
                const uniqueValues = [...new Set(allEntries.map(e => e.value))];
                content += createGroupSection('All unique entries after merge', uniqueValues);
                content += '<p><b>Reason:</b> Two separate groups were merged because of a tuple connection.</p><br>';
                if (Array.isArray(nodeData.merging_tuple) && nodeData.merging_tuple.length > 0) {
                    content += createDetailsTable(nodeData.merging_tuple, 'Merging tuple details', 'Details of the entries that caused the merge');
                } else {
                    content += '<h4>Merging tuple details <span class="tooltip" title="Details of the entries that caused the merge">ℹ</span></h4><p class="no-entries">N/A</p>';
                }
            }
            else if ((nodeData.type === 'Group' || nodeData.type === 'GroupFormed' || nodeData.type === 'GroupAdded' || nodeData.type === 'GroupJoined' || nodeData.type === 'Added') && Array.isArray(nodeData.formed_from) && nodeData.formed_from.length > 0) {
                if (nodeData.type === 'GroupFormed') {
                    const tupleEntries = nodeData.formed_from.filter(e => e && e.tuple_line !== undefined);
                    if (tupleEntries.length >= 2 && tupleEntries.every(e => e.tuple_line === tupleEntries[0].tuple_line)) {
                        content += `<h4>Group formed from tuple:</h4><p><b>Line ${tupleEntries[0].line}</b> at time ${tupleEntries[0].timestamp}</p>`;
                        content += createGroupSection('', tupleEntries).replace('<h4></h4>', '');
                        content += '<p><b>Reason:</b> These entries were found together on the same line and formed a tuple. Neither entry belonged to an existing group.</p><br>';
                        content += createDetailsTable(nodeData.formed_from, 'Forming tuple details', 'Details of the entries that caused this group to form');
                    }
                } else if (['GroupAdded', 'GroupJoined', 'Added'].includes(nodeData.type)) {
                    const uniqueValues = nodeData.entries ? [...new Set(nodeData.entries.map(entry => entry.value))] : [];
                    content += createGroupSection('Group now has:', uniqueValues);
                    content += '<p><b>Reason:</b> Entry was added to the group because of tuple below.</p><br>';
                    content += createDetailsTable(nodeData.formed_from, 'Adding tuple details', 'Details of the entries that caused this group to form');
                }
            }
            else if (nodeData.type === 'Group' && nodeData.merge_log && nodeData.merge_log.length > 0) {
                const formedLog = nodeData.merge_log.find(e => e.startsWith('FORMED:'));
                if (formedLog) {
                    const match = formedLog.match(/FORMED: \((.+?) , (.+?)\)/);
                    if (match) {
                        const [entryA, entryB] = [match[1].trim(), match[2].trim()];
                        const entryAinfo = nodeData.entries ? nodeData.entries.find(e => e.value === entryA) : null;
                        const entryBinfo = nodeData.entries ? nodeData.entries.find(e => e.value === entryB) : null;
                        const formattedEntries = [
                            entryAinfo ? `${entryA} <span class="entry-type">(line ${entryAinfo.line}, time ${entryAinfo.timestamp})</span>` : entryA,
                            entryBinfo ? `${entryB} <span class="entry-type">(line ${entryBinfo.line}, time ${entryBinfo.timestamp})</span>` : entryB
                        ];
                        content += createGroupSection('Group formed from:', formattedEntries);
                        content += '<p><b>Reason:</b> Both entries were not in any group, so a new group was formed.</p>';
                        content += createDetailsTable([entryAinfo, entryBinfo].filter(Boolean), 'Forming tuple details', 'Details of the two entries that caused this group to form');
                    }
                }
            }
            content += '</div>';
            showModal(nodeData.value, content);
        }

        function addClickEvents() {
            document.querySelectorAll('.clickable-node')
                .forEach(el => el.classList.remove('clickable-node'));
            
            document.querySelectorAll('.mermaid svg g[id]').forEach((element) => {
                if (element.id && !element.dataset.clickAdded) {
                    element.classList.add('clickable-node');
                    element.dataset.clickAdded = 'true';
                    element.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showNodeDetails(element.id);
                    });
                }
            });
        }

        function addGroupClickEvents() {
            document.querySelectorAll('.mermaid svg g[id]').forEach((element) => {
                if (element.id && element.id.startsWith('G')) {
                    const clean = element.cloneNode(true);
                    element.parentNode.replaceChild(clean, element);
                    clean.classList.add('clickable-node');
                    clean.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showNodeDetails(clean.id);
                    });
                }
            });
        }

        function renderMermaid(timeline) {
            document.getElementById('formation-timeline-container').innerHTML = `<div class="mermaid">${timeline}</div>`;
            mermaid.init(undefined, document.querySelector('#formation-timeline-container .mermaid'));
            setTimeout(() => {
                addClickEvents();
                addGroupClickEvents();
            }, 1000);
        }

        async function updateTimeline() {
            try {
                const response = await fetch('/api/timeline');
                const data = await response.json();
                if (data.timeline !== currentTimeline) {
                    currentTimeline = data.timeline;
                    selectedGroup = data.selected_group;
                    renderMermaid(currentTimeline);
                    const sel = document.getElementById('selected-group');
                    if (sel) sel.textContent = selectedGroup || 'None';
                }
            } catch (error) {
                console.error('Error updating timeline:', error);
            }
        }

        function updateTimelineWithDirection() {
            fetch('/api/timeline')
                .then(response => response.json())
                .then(data => {
                    const timeline = data.timeline.replace(/flowchart (TD|LR)/, `flowchart ${chartDirection}`);
                    renderMermaid(timeline);
                })
                .catch(error => console.error('Error updating timeline direction:', error));
        }

        function selectGroup(groupId) {
            fetch(`/api/select-group/${groupId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentTimeline = data.timeline;
                        selectedGroup = data.selected_group;
                        renderMermaid(currentTimeline);
                        loadNodesVisualization(groupId);
                        const sel = document.getElementById('selected-group');
                        if (sel) sel.textContent = selectedGroup;
                        chartDirection = 'TD';
                        const directionBtn = document.getElementById('direction-btn');
                        if (directionBtn) directionBtn.textContent = 'Top Down';
                    } else {
                        alert('Error selecting group: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error selecting group:', error);
                    alert('Error selecting group: ' + error.message);
                });
        }

        async function loadNodesVisualization(groupId) {
            try {
                const response = await fetch(`/api/visualization/nodes/${groupId}`);
                const data = await response.json();
                
                if (data.success) {
                    const nodesContainer = document.getElementById('nodes-container');
                    nodesContainer.innerHTML = `<div class="mermaid">${data.visualization}</div>`;
                    mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
                    setTimeout(() => {
                        addClickEvents();
                    }, 1000);
                } else {
                    console.error('Failed to load nodes visualization:', data.error);
                    const nodesContainer = document.getElementById('nodes-container');
                    nodesContainer.innerHTML = `<div class="mermaid">flowchart TD\n    ERROR["${data.error || 'Failed to load nodes visualization'}"]</div>`;
                    mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
                }
            } catch (error) {
                console.error('Error loading nodes visualization:', error);
                const nodesContainer = document.getElementById('nodes-container');
                nodesContainer.innerHTML = `<div class="mermaid">flowchart TD\n    ERROR["Connection error"]</div>`;
                mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
            }
        }

        async function loadGroups() {
            try {
                const response = await fetch('/api/groups');
                const groups = await response.json();
                const selector = document.getElementById('group-selector');
                selector.innerHTML = '<option value="">Select a group...</option>';
                Object.keys(groups).forEach(groupId => {
                    const group = groups[groupId];
                    const option = document.createElement('option');
                    option.value = groupId;
                    option.textContent = `${groupId} (${group.count} entries, ${group.nodes} nodes)`;
                    if (groupId === selectedGroup) option.selected = true;
                    selector.appendChild(option);
                });
                selector.addEventListener('change', function() {
                    if (this.value) selectGroup(this.value);
                });
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        function showTechnicalModal(technicalData) {
            modalTitle.textContent = 'Filtered Entries';

            const storageKey = 'mermetro_excludedEntries_v1';
            let savedExcluded = null;
            try {
                const raw = localStorage.getItem(storageKey);
                if (raw) savedExcluded = JSON.parse(raw);
            } catch (e) {
                console.warn('Failed to read saved excluded entries', e);
            }

            const nodeListHtml = technicalData.length > 0 ? 
                technicalData.map(value => 
                    `<div class="checkbox-item">
                        <input type="checkbox" id="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}" 
                            class="entry-checkbox" value="${value}">
                        <label for="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}">${value}</label>
                    </div>`
                ).join('') : 'N/A';

            modalContent.innerHTML = `
                <div class="detail-section">
                    <p><strong>Total unique values:</strong> ${technicalData.length}</p>

                    <div style="margin:10px 0;">
                        <input id="newCommonValue" type="text" placeholder="Remove / Add value to common_values.txt" 
                               style="padding:6px; width:70%; margin-right:8px;">
                        <button id="addCommonButton" class="filter-button">Remove / Add common value</button>
                    </div>

                    <p><strong>Filtered Entries:</strong>
                        <span class="info-tooltip">
                            ?
                            <span class="tooltip-text">These values are either marked as filtered types or found in common_values.txt file. Checking entries will include them in the metromap logic (they can form or merge groups).</span>
                        </span>    
                    </p>
                    <div class="checkbox-container">
                        <button id="selectAllButton" class="filter-button">Select All</button>
                        <button id="deselectAllButton" class="filter-button">Deselect All</button>
                        <div class="checkbox-list">${nodeListHtml}</div>
                    </div>
                    <div class="reload-container">
                        <button id="reloadMapButton" class="reload-button">Process</button>
                        <button id="reloadMapMPButton" class="reload-button">Process (MP)</button>
                    </div>
                </div>
            `;

            const checkboxList = modalContent.querySelector('.checkbox-list');

            checkboxList.onchange = function(e) {
                const cb = e.target;
                if (!cb || !cb.classList || !cb.classList.contains('entry-checkbox')) return;
                if (cb.checked) {
                    excludedEntries = excludedEntries.filter(item => item !== cb.value);
                } else {
                    if (!excludedEntries.includes(cb.value)) excludedEntries.push(cb.value);
                }
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };

            const selectAllBtn = document.getElementById('selectAllButton');
            const deselectAllBtn = document.getElementById('deselectAllButton');
            selectAllBtn.onclick = function() {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(checkbox => checkbox.checked = true);
                excludedEntries = [];
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };
            deselectAllBtn.onclick = function() {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(checkbox => checkbox.checked = false);
                excludedEntries = Array.from(checkboxList.querySelectorAll('.entry-checkbox')).map(cb => cb.value);
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };

            if (Array.isArray(savedExcluded)) {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(cb => {
                    cb.checked = !savedExcluded.includes(cb.value);
                });
                excludedEntries = savedExcluded.slice();
            } else {
                deselectAllBtn.click();
            }

            function performReload(multiprocessing) {
                const normalBtn = document.getElementById('reloadMapButton');
                const mpBtn = document.getElementById('reloadMapMPButton');
                const activeBtn = multiprocessing ? mpBtn : normalBtn;

                const originalText = activeBtn.textContent;
                activeBtn.textContent = 'Processing...';
                normalBtn.disabled = true;
                mpBtn.disabled = true;

                fetch('/api/reload-metromap', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify({ 
                        excludedEntries: excludedEntries,
                        multiprocessing: multiprocessing 
                    }),
                    cache: 'no-store'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showRefreshNotification();
                        return updateMetromap();
                    }
                    alert('Process failed');
                })
                .finally(() => {
                    activeBtn.textContent = originalText;
                    normalBtn.disabled = false;
                    mpBtn.disabled = false;
                });
            }

            document.getElementById('reloadMapButton').onclick = function() { performReload(false); };
            document.getElementById('reloadMapMPButton').onclick = function() { performReload(true); };

            const addCommonBtn = document.getElementById('addCommonButton');
            addCommonBtn.onclick = async function() {
                const val = document.getElementById('newCommonValue').value.trim();
                if (!val) { alert('Enter a non-empty value.'); return; }
                if (val.length > 500 || val.includes('\n') || val.includes('\r')) { alert('Value too long or contains invalid characters.'); return; }

                let originalText = addCommonBtn.textContent;
                try {
                    const existing = await fetch('/api/technical-entries', { cache: 'no-store' }).then(r => r.json());
                    const willRemove = Array.isArray(existing) && existing.includes(val);

                    addCommonBtn.textContent = willRemove ? 'Removing...' : 'Adding...';
                    addCommonBtn.disabled = true;

                    const resp = await fetch('/api/common/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ value: val })
                    }).then(r => r.json());

                    if (resp.success) {
                        if (resp.action === 'removed') alert('Removed from common_values.txt');
                        else if (resp.action === 'added') alert('Added to common_values.txt');
                        else alert('Updated common_values.txt');

                        const data = await fetch('/api/technical-entries', { cache: 'no-store' }).then(r => r.json());
                        checkboxList.innerHTML = data.map(value => 
                            `<div class="checkbox-item">
                                <input type="checkbox" id="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                    class="entry-checkbox" value="${value}">
                                <label for="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}">${value}</label>
                            </div>`
                        ).join('');
                        
                        try {
                            const raw = localStorage.getItem(storageKey);
                            if (raw) {
                                const currentSaved = JSON.parse(raw);
                                checkboxList.querySelectorAll('.entry-checkbox').forEach(cb => {
                                    cb.checked = !currentSaved.includes(cb.value);
                                });
                                excludedEntries = currentSaved.slice();
                            } else {
                                deselectAllBtn.click();
                            }
                        } catch (e) {
                            deselectAllBtn.click();
                        }
                    } else {
                        alert('Operation failed: ' + (resp.message || 'unknown'));
                    }
                } catch (err) {
                    console.error(err);
                    alert('Request failed');
                } finally {
                    addCommonBtn.textContent = originalText;
                    addCommonBtn.disabled = false;
                }
            };

            modal.style.display = 'block';
        }

        async function updateMetromap(ignoreTimeFilters = false) {
            try {
                const params = new URLSearchParams();
                params.append('t', Date.now());

                if (ignoreTimeFilters) {
                    params.append('reset', '1');
                } else {
                    const startDate = document.getElementById('startDate')?.value;
                    const startTime = document.getElementById('startTime')?.value;
                    const endDate = document.getElementById('endDate')?.value;
                    const endTime = document.getElementById('endTime')?.value;

                    if (startDate) {
                        const startDateTime = startTime ? `${startDate}T${startTime}` : `${startDate}T00:00:00`;
                        params.append('start', startDateTime);
                    }
                    if (endDate) {
                        const endDateTime = endTime ? `${endDate}T${endTime}` : `${endDate}T23:59:59`;
                        params.append('end', endDateTime);
                    }
                }

                const response = await fetch(`/api/metromap?${params.toString()}`);
                const data = await response.json();

                if (data.metromap !== currentMetromap) {
                    currentMetromap = data.metromap;
                    const container = document.getElementById('metromap-container');
                    container.innerHTML = `<div class="mermaid">${currentMetromap}</div>`;

                    await mermaid.run({ querySelector: '#metromap-container .mermaid' });
                    setTimeout(addClickEvents, 100);
                    const ts = document.getElementById('timestamp');
                    if (ts) ts.textContent = data.timestamp;
                }
            } catch (error) {
                console.error('Update error:', error);
            }
        }

        function showRefreshNotification() {
            const notification = document.createElement('div');
            notification.id = 'refreshNotification';
            notification.className = 'refresh-notification';
            notification.innerHTML = `
                <div class="refresh-notification-content">
                    <h3>Metromap Updated Successfully!</h3>
                    <strong>Please refresh the page to see the updated groups and timeline.</strong></p>
                    <div class="refresh-buttons">
                        <button id="refreshPageButton" class="refresh-page-button">Refresh Page Now</button>
                        <button id="dismissButton" class="dismiss-button">Dismiss</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            document.getElementById('refreshPageButton').addEventListener('click', function() {
                location.reload();
            });
            
            document.getElementById('dismissButton').addEventListener('click', function() {
                notification.remove();
            });
        }
        
        function showModal(title, content) {
            modalTitle.textContent = title;
            modalContent.innerHTML = content;
            modal.style.display = 'block';
        }

        document.addEventListener('DOMContentLoaded', function() {
            modal = document.getElementById('nodeModal');
            modalTitle = document.getElementById('modalTitle');
            modalContent = document.getElementById('modalContent');
            
            const directionBtn = document.getElementById('direction-btn');
            directionBtn.addEventListener('click', function() {
                chartDirection = (chartDirection === 'TD') ? 'LR' : 'TD';
                directionBtn.textContent = (chartDirection === 'TD') ? 'Top Down' : 'Left Right';
                updateTimelineWithDirection();
            });

            const groupLogModal = document.getElementById('groupLogModal');
            
            document.querySelector('#nodeModal .close').addEventListener('click', () => modal.style.display = 'none');
            document.querySelector('#groupLogModal .close').addEventListener('click', () => groupLogModal.style.display = 'none');
            
            window.addEventListener('click', function(event) {
                if (event.target === modal) modal.style.display = 'none';
                if (event.target === groupLogModal) groupLogModal.style.display = 'none';
            });

            document.getElementById('technicalButton').addEventListener('click', function() {
                fetch('/api/technical-entries')
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            showTechnicalModal(data);
                        }
                    })
                    .catch(error => console.error('Error:', error));
            });

            const applyBtn = document.getElementById('applyTimeRangeButton');
            const clearBtn = document.getElementById('clearTimeRangeButton');
            if (applyBtn) {
                applyBtn.addEventListener('click', function() {
                    const startDate = document.getElementById('startDate').value;
                    const startTime = document.getElementById('startTime').value;
                    const endDate = document.getElementById('endDate').value;
                    const endTime = document.getElementById('endTime').value;

                    if (startDate && endDate) {
                        const startDateTime = `${startDate}T${startTime || '00:00:00'}`;
                        const endDateTime = `${endDate}T${endTime || '23:59:59'}`;

                        if (startDateTime > endDateTime) {
                            alert('Start time must be before end time');
                            return;
                        }
                    }

                    applyBtn.textContent = 'Reloading...';
                    applyBtn.disabled = true;

                    updateMetromap().finally(() => {
                        applyBtn.textContent = 'Apply Time Range';
                        applyBtn.disabled = false;
                        showRefreshNotification();
                    });
                });
            }
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearBtn.textContent = 'Resetting...';
                    clearBtn.disabled = true;

                    document.getElementById('startDate').value = '';
                    document.getElementById('startTime').value = '00:00:00';
                    document.getElementById('endDate').value = '';
                    document.getElementById('endTime').value = '23:59:59';

                    updateMetromap(true).finally(() => {
                        clearBtn.textContent = 'Reset';
                        clearBtn.disabled = false;
                        showRefreshNotification();
                    });
                });
            }

            loadGroups();
            if (selectedGroup) updateTimeline();

            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.addedNodes.length && document.querySelector('.mermaid svg')) {
                        addClickEvents();
                        addGroupClickEvents();
                        observer.disconnect();
                    }
                });
            });
            observer.observe(document.querySelector('.mermaid'), { childList: true, subtree: true });
            
            setTimeout(() => {
                addClickEvents();
                addGroupClickEvents();
            }, 2000);

            updateMetromap();
        });

        setInterval(updateTimeline, 30000);
    </script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .header { background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .status { color: #4CAF50; font-weight: bold; }
        .mermaid { text-align: center; background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-height: 400px; }
        #nodes-container { background-color: transparent; padding: 0; border-radius: 0; box-shadow: none; margin-top: 20px; min-height: 0; }
        #nodes-container .section-header { margin-bottom: 15px; }
        .diagram-section { margin-bottom: 30px; }
        h1 { color: #333; text-align: center; margin: 0 0 20px 0; }
        .controls { background-color: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: inline-block; width: 120px; font-weight: bold; }
        #group-selector { padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 300px; }
        #technicalButton { padding: 8px 16px; color: white; border: none; border-radius: 5px; font-size: 14px; cursor: pointer; font-family: inherit; font-weight: bold; background-color: #FF9800; margin-left: auto; }
        #technicalButton:hover { background-color: #F57C00; opacity: 0.9; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: none; width: 90%; max-width: 800px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-height: 80vh; overflow-y: auto; font-family: inherit; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover, .close:focus { color: black; text-decoration: none; }
        .entries-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .entries-table th, .entries-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .entries-table th { background-color: #2196F3; color: white; font-weight: bold; }
        .entries-table.technical th { background-color: #FF9800; color: white; }
        .entries-table td:first-child, .entries-table td:nth-child(2) { text-align: center; font-weight: bold; color: #1976D2; }
        .technical-section { margin-top: 20px; padding-top: 15px; border-top: 2px solid #FF9800; }
        .technical-table td:first-child, .technical-table td:nth-child(2) { text-align: center; font-weight: bold; color: #F57C00; }
        .entries-table tr:nth-child(even) { background-color: #f9f9f9; }
        .value-cell { max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-container { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; }
        .entries-section { margin-bottom: 20px; }
        .entries-section h4 { color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px; margin-top: 0; }
        .node-info { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-bottom: 2px solid #2196F3; }
        .node-info p { margin: 5px 0; }
        .merge-log { background-color: #fff3cd; padding: 15px; border-radius: 5px; border: 1px solid #ffeaa7; }
        .merge-entry { background-color: white; padding: 10px; margin: 5px 0; border-radius: 3px; border-left: 3px solid #f39c12; font-family: monospace; font-size: 12px; white-space: pre-wrap; }
        .tooltip { cursor: help; color: #1976D2; }
        .node { cursor: pointer; transition: opacity 0.2s; }
        .node:hover { opacity: 0.8; }
        #direction-btn { padding: 6px 18px; font-size: 15px; border: 1px solid #2196f3; background: #fff; color: #2196f3; border-radius: 5px; cursor: pointer; font-weight: bold; margin-left: 10px; }
        #direction-btn:hover { background: #e3f2fd; }
        .group-section { margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border-left: 3px solid #2196F3; }
        .entry-list { margin: 8px 0; padding-left: 0; list-style: none; }
        .entry-list li { margin: 4px 0; padding: 2px 0; font-family: monospace; font-size: 13px; word-break: break-all; overflow-wrap: anywhere; }
        .entry-type { color: #666; font-size: 11px; font-style: italic; }
        .no-entries { color: #999; font-style: italic; margin: 5px 0; }
        .detail-section { margin-bottom: 20px; }
        .detail-section h4 { color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px; margin-top: 0; }
        .detail-section p { color: #333; font-weight: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .info-tooltip { position: relative; display: inline-block; background-color: #2196F3; color: white; border-radius: 50%; width: 16px; height: 16px; text-align: center; font-size: 12px; font-weight: bold; line-height: 16px; cursor: help; margin-left: 5px; vertical-align: top; }
        .info-tooltip:hover { background-color: #1976D2; }
        .tooltip-text { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1001; bottom: 125%; left: 50%; margin-left: -125px; font-size: 13px; font-weight: normal; line-height: 1.3; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .tooltip-text::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #333 transparent transparent transparent; }
        .info-tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
        .checkbox-container { margin-top: 15px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background-color: #f9f9f9; }
        .checkbox-list { margin-top: 10px; border-top: 1px solid #ddd; padding-top: 10px; }
        .checkbox-item { margin: 5px 0; display: flex; align-items: center; }
        .checkbox-item input { margin-right: 8px; cursor: pointer; }
        .checkbox-item label { cursor: pointer; word-break: break-all; }
        .filter-button { background-color: #607D8B; color: white; border: none; padding: 5px 10px; border-radius: 4px; margin-right: 10px; cursor: pointer; font-size: 12px; }
        .filter-button:hover { background-color: #455A64; }
        .reload-container { margin-top: 20px; text-align: center; }
        .reload-button { background-color: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; transition: background-color 0.3s; }
        .reload-button:hover { background-color: #388E3C; }
        .reload-button:disabled { background-color: #A5D6A7; cursor: not-allowed; }
        .timerange-container { margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding: 10px; background-color: #f9f9f9; border-radius: 5px; border: 1px solid #ddd; }
        .timerange-container label { font-weight: bold; color: #333; font-size: 14px; }
        .timerange-container input[type="date"], .timerange-container input[type="time"] { padding: 6px 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 14px; font-family: inherit; background-color: white; }
        .timerange-container input[type="date"]:focus, .timerange-container input[type="time"]:focus { outline: none; border-color: #2196F3; }
        .timerange-container button { padding: 8px 16px; color: white; border: none; border-radius: 5px; font-size: 14px; cursor: pointer; font-family: inherit; font-weight: bold; }
        #applyTimeRangeButton { background-color: #4CAF50; }
        #applyTimeRangeButton:hover { background-color: #388E3C; }
        #clearTimeRangeButton { background-color: #757575; }
        #clearTimeRangeButton:hover { background-color: #424242; }
        .refresh-notification { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 2000; display: flex; align-items: center; justify-content: center; }
        .refresh-notification-content { background-color: white; padding: 30px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); text-align: center; max-width: 500px; margin: 20px; animation: slideIn 0.3s ease-out; }
        .refresh-notification-content h3 { color: #4CAF50; margin: 0 0 15px 0; font-size: 20px; }
        .refresh-notification-content p { color: #333; margin: 0 0 20px 0; line-height: 1.5; }
        .refresh-buttons { display: flex; gap: 15px; justify-content: center; }
        .refresh-page-button { background-color: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        .refresh-page-button:hover { background-color: #388E3C; }
        .dismiss-button { background-color: #757575; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        .dismiss-button:hover { background-color: #616161; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-50px); } to { opacity: 1; transform: translateY(0); } }

    </style>
</head>
<body>
    <div class="header"><h1>Mermetro2</h1></div>
    <div class="controls">
        <div class="control-group">
            <label for="group-selector">Select Group:</label>
            <select id="group-selector"></select>
        </div>
        <div class="control-group">
            <label>Selected:</label>
            <span id="selected-group" class="status">{{ selected_group or 'None' }}</span>
        </div>
        <div class="control-group">
            <label>Last Update:</label>
            <span id="timestamp" class="status">{{ timestamp }}</span>
        </div>
        <button id="technicalButton">Filtered Entries</button>
    </div>

    <div class="timerange-container">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" placeholder="yyyy-mm-dd">
        <label for="startTime">Time:</label>
        <input type="time" id="startTime" value="00:00:00" step="1">

        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" placeholder="yyyy-mm-dd">
        <label for="endTime">Time:</label>
        <input type="time" id="endTime" value="23:59:59" step="1">

        <button id="applyTimeRangeButton">Apply Time Range</button>
        <button id="clearTimeRangeButton">Reset</button>
    </div>

    <div class="diagram-section">
        <div class="section-header">
            <h2>Group Formation Timeline</h2>
            <div class="control-group">
                <label for="direction-btn" style="margin-right:10px;">Swap Direction</label>
                <button id="direction-btn" type="button">Top Down</button>
            </div>
        </div>
        <div class="diagram-container" id="formation-timeline-container">
            {% if timeline %}
            <div class="mermaid">{{ timeline|safe }}</div>
            {% else %}
            <div class="mermaid"></div>
            {% endif %}
        </div>
    </div>
    <div class="diagram-section">
        <div class="section-header">
            <h2>Node Relationships</h2>
            <p style="color: #666; font-size: 14px; margin: 5px 0;">Shows internal connections between group entries</p>
        </div>
        <div class="diagram-container" id="nodes-container">
            <div class="mermaid" id="nodes-mermaid"></div>
        </div>
    </div>
    <div id="nodeModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="modalTitle">Details</h2>
            <div id="modalContent"></div>
        </div>
    </div>
    <div id="groupLogModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="document.getElementById('groupLogModal').style.display='none'">&times;</span>
            <h2 id="groupLogModalTitle">Group Formation Log</h2>
            <div id="groupLogModalContent"></div>
        </div>
    </div>
</body>
</html>
