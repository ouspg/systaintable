<!DOCTYPE html>
<html>
<head>
    <title>Mermetro2</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.3/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            maxTextSize: 10000000000,
            maxEdges: 500000,
            startOnLoad: false,
            flowchart: { htmlLabels: true, curve: 'linear' },
            securityLevel: 'loose'
        });
        let currentTimeline = '';
        let selectedGroup = '{{ selected_group }}';
        let chartDirection = 'TD';
        
        let modal, modalTitle, modalContent;
        
        let excludedEntries = [];
        
        let currentMetromap = '';

        let heatmapData = null;
        let heatmapSegments = [];
        let maxActivityCount = 0;

        function createGroupSection(title, entries) {
            return `
                <h4>${title}</h4>
                ${entries && entries.length > 0 ? `
                    <div class="group-section">
                        <ul class="entry-list">
                            ${entries.map(entry => {
                                let value, type;
                                if (entry && typeof entry === 'object') {
                                    value = entry.value !== undefined ? entry.value : entry;
                                    type = entry.type || '';
                                } else {
                                    value = entry;
                                    type = '';
                                }
                                const isUrl = typeof value === 'string' && value.startsWith('http');
                                const valueHtml = isUrl ? `<span class="url-value" title="${value}">${value}</span>` : `${value}`;
                                return `<li>• ${valueHtml}${type ? ` <span class="entry-type">(${type})</span>` : ''}</li>`;
                            }).join('')}
                        </ul>
                    </div>
                ` : '<p class="no-entries">N/A</p>'}
            `;
        }

        function createDetailsTable(entries, title, tooltipText) {
            return `
                <div class="entries-section">
                    <h4>${title} <span class="tooltip" title="${tooltipText}">ℹ</span></h4>
                    <div class="table-container">
                        <table class="entries-table">
                            <thead><tr><th>Line</th><th>Timestamp</th><th>Type</th><th>Value</th></tr></thead>
                            <tbody>
                                ${entries.map(entry => `
                                    <tr>
                                        <td>${entry.line || ''}</td>
                                        <td>${entry.timestamp || ''}</td>
                                        <td>${entry.type || ''}</td>
                                        <td class="value-cell" title="${entry.value || ''}">${entry.value || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        window.showNodeDetails = function(nodeId) {
            const cleanNodeId = nodeId.startsWith('flowchart-') ? nodeId.substring(10) : nodeId;
            fetch(`/api/v2/node-details/${cleanNodeId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Node "${cleanNodeId}" not found`);
                        return;
                    }
                    showNodeOrGroupModal(data);
                })
                .catch(error => alert(`Failed to fetch details: ${error.message}`));
        }

        function showNodeOrGroupModal(nodeData) {
            let content = '<div class="node-info">';
            if (nodeData.type === 'LineEntries') {
                content += `<h4>All entries on line ${nodeData.line}</h4>`;
                if (Array.isArray(nodeData.entries) && nodeData.entries.length > 0) {
                    content += createDetailsTable(nodeData.entries, 'Line entries', 'All entries that appeared on this log line');
                } else {
                    content += '<p class="no-entries">N/A</p>';
                }
            }
            else if (nodeData.type === 'GroupMerged') {
                content += '<h4>Merged groups</h4>';
                if (Array.isArray(nodeData.merged_groups)) {
                    nodeData.merged_groups.forEach((group, idx) => {
                        content += `<div class="group-section"><b>Group ${idx + 1}:</b><br/>`;
                        if (Array.isArray(group.entries) && group.entries.length > 0) {
                            content += '<ul class="entry-list">';
                            group.entries.forEach(entry => {
                                content += `<li>• ${entry.value} <span class="entry-type">(${entry.type})</span></li>`;
                            });
                            content += '</ul>';
                        } else {
                            content += '<p class="no-entries">N/A</p>';
                        }
                        content += '</div>';
                    });
                } else {
                    content += '<p>N/A</p>';
                }
                const allEntries = Array.isArray(nodeData.entries) ? nodeData.entries : [];
                const uniqueValues = [...new Set(allEntries.map(e => e.value))];
                content += createGroupSection('All unique entries after merge', uniqueValues);
                content += '<p><b>Reason:</b> Two separate groups were merged because of a tuple connection.</p><br>';
                if (Array.isArray(nodeData.merging_tuple) && nodeData.merging_tuple.length > 0) {
                    content += createDetailsTable(nodeData.merging_tuple, 'Merging tuple details', 'Details of the entries that caused the merge');
                } else {
                    content += '<h4>Merging tuple details <span class="tooltip" title="Details of the entries that caused the merge">ℹ</span></h4><p class="no-entries">N/A</p>';
                }
            }
            else if ((nodeData.type === 'Group' || nodeData.type === 'GroupFormed' || nodeData.type === 'GroupAdded' || nodeData.type === 'GroupJoined' || nodeData.type === 'Added') && Array.isArray(nodeData.formed_from) && nodeData.formed_from.length > 0) {
                if (nodeData.type === 'GroupFormed') {
                    const tupleEntries = nodeData.formed_from.filter(e => e && e.tuple_line !== undefined);
                    if (tupleEntries.length >= 2 && tupleEntries.every(e => e.tuple_line === tupleEntries[0].tuple_line)) {
                        content += `<h4>Group formed from tuple:</h4><p><b>Line ${tupleEntries[0].line}</b> at time ${tupleEntries[0].timestamp}</p>`;
                        content += createGroupSection('', tupleEntries).replace('<h4></h4>', '');
                        content += '<p><b>Reason:</b> These entries were found together on the same line and formed a tuple. Neither entry belonged to an existing group.</p><br>';
                        content += createDetailsTable(nodeData.formed_from, 'Forming tuple details', 'Details of the entries that caused this group to form');
                    }
                } else if (['GroupAdded', 'GroupJoined', 'Added'].includes(nodeData.type)) {
                    const uniqueValues = nodeData.entries ? [...new Set(nodeData.entries.map(entry => entry.value))] : [];
                    content += createGroupSection('Group now has:', uniqueValues);
                    content += '<p><b>Reason:</b> Entry was added to the group because of tuple below.</p><br>';
                    content += createDetailsTable(nodeData.formed_from, 'Adding tuple details', 'Details of the entries that caused this group to form');
                }
            }
            else if (nodeData.type === 'Group' && nodeData.merge_log && nodeData.merge_log.length > 0) {
                const formedLog = nodeData.merge_log.find(e => e.startsWith('FORMED:'));
                if (formedLog) {
                    const match = formedLog.match(/FORMED: \((.+?) , (.+?)\)/);
                    if (match) {
                        const [entryA, entryB] = [match[1].trim(), match[2].trim()];
                        const entryAinfo = nodeData.entries ? nodeData.entries.find(e => e.value === entryA) : null;
                        const entryBinfo = nodeData.entries ? nodeData.entries.find(e => e.value === entryB) : null;
                        const formattedEntries = [
                            entryAinfo ? `${entryA} <span class="entry-type">(line ${entryAinfo.line}, time ${entryAinfo.timestamp})</span>` : entryA,
                            entryBinfo ? `${entryB} <span class="entry-type">(line ${entryBinfo.line}, time ${entryBinfo.timestamp})</span>` : entryB
                        ];
                        content += createGroupSection('Group formed from:', formattedEntries);
                        content += '<p><b>Reason:</b> Both entries were not in any group, so a new group was formed.</p>';
                        content += createDetailsTable([entryAinfo, entryBinfo].filter(Boolean), 'Forming tuple details', 'Details of the two entries that caused this group to form');
                    }
                }
            }
            content += '</div>';
            showModal(nodeData.value, content);
        }

        function addClickEvents() {
            document.querySelectorAll('.clickable-node')
                .forEach(el => el.classList.remove('clickable-node'));
            
            document.querySelectorAll('.mermaid svg g[id]').forEach((element) => {
                if (element.id && !element.dataset.clickAdded) {
                    element.classList.add('clickable-node');
                    element.dataset.clickAdded = 'true';
                    element.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showNodeDetails(element.id);
                    });
                }
            });
        }

        function addGroupClickEvents() {
            document.querySelectorAll('.mermaid svg g[id]').forEach((element) => {
                if (element.id && element.id.startsWith('G')) {
                    const clean = element.cloneNode(true);
                    element.parentNode.replaceChild(clean, element);
                    clean.classList.add('clickable-node');
                    clean.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showNodeDetails(clean.id);
                    });
                }
            });
        }

        function renderMermaid(timeline) {
            document.getElementById('formation-timeline-container').innerHTML = `<div class="mermaid">${timeline}</div>`;
            mermaid.init(undefined, document.querySelector('#formation-timeline-container .mermaid'));
            setTimeout(() => {
                addClickEvents();
                addGroupClickEvents();
            }, 1000);
        }

        async function updateTimeline() {
            try {
                const response = await fetch('/api/v2/timeline');
                const data = await response.json();
                if (data.timeline !== currentTimeline) {
                    currentTimeline = data.timeline;
                    selectedGroup = data.selected_group;
                    renderMermaid(currentTimeline);
                    const sel = document.getElementById('selected-group');
                    if (sel) sel.textContent = selectedGroup || 'None';
                }
            } catch (error) {
                console.error('Error updating timeline:', error);
            }
        }

        function updateTimelineWithDirection() {
            fetch('/api/v2/timeline')
                .then(response => response.json())
                .then(data => {
                    const timeline = data.timeline.replace(/flowchart (TD|LR)/, `flowchart ${chartDirection}`);
                    renderMermaid(timeline);
                })
                .catch(error => console.error('Error updating timeline direction:', error));
        }

        function selectGroup(groupId) {
            fetch(`/api/v2/select-group/${groupId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentTimeline = data.timeline;
                        selectedGroup = data.selected_group;
                        renderMermaid(currentTimeline);
                        loadNodesVisualization(groupId);
                        loadTimelineHeatmap(groupId); 
                        const sel = document.getElementById('selected-group');
                        if (sel) sel.textContent = selectedGroup;
                        chartDirection = 'TD';
                        const directionBtn = document.getElementById('direction-btn');
                        if (directionBtn) directionBtn.textContent = 'Top Down';
                    } else {
                        alert('Error selecting group: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error selecting group:', error);
                    alert('Error selecting group: ' + error.message);
                });
        }

        async function loadNodesVisualization(groupId) {
            try {
                const response = await fetch(`/api/v2/visualization/nodes/${groupId}`);
                const data = await response.json();
                
                if (data.success) {
                    const nodesContainer = document.getElementById('nodes-container');
                    nodesContainer.innerHTML = `<div class="mermaid">${data.visualization}</div>`;
                    mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
                    setTimeout(() => {
                        addClickEvents();
                    }, 1000);
                } else {
                    console.error('Failed to load nodes visualization:', data.error);
                    const nodesContainer = document.getElementById('nodes-container');
                    nodesContainer.innerHTML = `<div class="mermaid">flowchart TD\n    ERROR["${data.error || 'Failed to load nodes visualization'}"]</div>`;
                    mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
                }
            } catch (error) {
                console.error('Error loading nodes visualization:', error);
                const nodesContainer = document.getElementById('nodes-container');
                nodesContainer.innerHTML = `<div class="mermaid">flowchart TD\n    ERROR["Connection error"]</div>`;
                mermaid.init(undefined, nodesContainer.querySelector('.mermaid'));
            }
        }

        async function loadGroups() {
            try {
                const response = await fetch('/api/v2/groups');
                const groups = await response.json();
                const selector = document.getElementById('group-selector');
                selector.innerHTML = '<option value="">Select a group...</option>';
                Object.keys(groups).forEach(groupId => {
                    const group = groups[groupId];
                    const option = document.createElement('option');
                    option.value = groupId;
                    option.textContent = `${groupId} (${group.count} entries, ${group.nodes} nodes)`;
                    if (groupId === selectedGroup) option.selected = true;
                    selector.appendChild(option);
                });
                selector.addEventListener('change', function() {
                    if (this.value) selectGroup(this.value);
                });
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        async function loadTimelineHeatmap(groupId = null) {
            try {
                const url = groupId ? `/api/v2/timeline-heatmap/${groupId}` : '/api/v2/timeline-heatmap';
                const response = await fetch(url);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load heatmap data');
                }
                
                heatmapData = data;
                heatmapSegments = data.segments;
                maxActivityCount = heatmapSegments.length > 0 ? 
                    Math.max(...heatmapSegments.map(s => s.count)) : 0;
                
                renderTimelineHeatmap();
                renderHeatmapStatistics();
                
                console.log('DEBUG: heatmapData after load:', heatmapData);
                console.log('DEBUG: heatmapData.statistics:', heatmapData?.statistics);
                
                if (groupId) {
                    console.log(`Loaded heatmap for group ${groupId}: ${data.total_entries} entries, ${data.segments.length} segments`);
                } else {
                    console.log(`Loaded heatmap: ${data.total_entries} entries, ${data.segments.length} segments`);
                }
            } catch (error) {
                console.error('Timeline heatmap loading failed:', error);
                const heatmapContainer = document.getElementById('timelineHeatmapBar');
                if (heatmapContainer) {
                    heatmapContainer.innerHTML = '<div class="heatmap-error">Failed to load timeline data</div>';
                }
            }
        }

        function renderTimelineHeatmap() {
            if (!heatmapData || !heatmapSegments.length) return;
            
            const heatmapContainer = document.getElementById('timelineHeatmapBar');
            if (!heatmapContainer) return;
            
            const startSpan = document.getElementById('heatmapStart');
            const endSpan = document.getElementById('heatmapEnd');
            if (startSpan) startSpan.textContent = new Date(heatmapData.min_timestamp).toLocaleString();
            if (endSpan) endSpan.textContent = new Date(heatmapData.max_timestamp).toLocaleString();
            
            heatmapContainer.innerHTML = '';
            const fragment = document.createDocumentFragment();
            
            const segmentWidth = 100 / heatmapSegments.length;
            const activityColors = {
                'none': '#e0e0e0',
                'low': '#81c784',
                'medium': '#ffb74d', 
                'high': '#f06292',
                'extreme': '#e57373'
            };
            
            heatmapSegments.forEach((segment, index) => {
                const segmentDiv = document.createElement('div');
                segmentDiv.className = 'heatmap-segment';
                
                const intensity = maxActivityCount > 0 ? segment.count / maxActivityCount : 0;
                const backgroundColor = activityColors[segment.activity_level] || activityColors.none;
                
                Object.assign(segmentDiv.style, {
                    left: `${index * segmentWidth}%`,
                    width: `${segmentWidth}%`,
                    backgroundColor,
                    opacity: Math.max(0.1, intensity)
                });
                
                segmentDiv.title = `${segment.count} entries (${segment.activity_level})\nType: ${segment.dominant_type}\nClick to view entries`;
                
                segmentDiv.onmouseenter = () => {
                    segmentDiv.style.transform = 'scaleY(1.2)';
                    segmentDiv.style.zIndex = '10';
                };
                segmentDiv.onmouseleave = () => {
                    segmentDiv.style.transform = 'scaleY(1)';
                    segmentDiv.style.zIndex = '1';
                };
                
                segmentDiv.onclick = () => {
                    showHeatmapSegmentEntries(segment.start, segment.end);
                };
                
                fragment.appendChild(segmentDiv);
            });
            
            heatmapContainer.appendChild(fragment);
            renderTimeLabels(heatmapContainer);
        }
        
        function renderTimeLabels(container) {
            if (!heatmapData?.min_timestamp || !heatmapData?.max_timestamp) {
                console.log('No heatmap data available for time labels');
                return;
            }
            
            const startTime = new Date(heatmapData.min_timestamp);
            const endTime = new Date(heatmapData.max_timestamp);
            const totalDuration = endTime - startTime;
            const segmentCount = heatmapSegments.length;
            
            const activityMap = new Map();
            heatmapSegments.forEach((segment, index) => {
                activityMap.set(index, {
                    level: segment.activity_level,
                    hasActivity: ['medium', 'high', 'extreme'].includes(segment.activity_level)
                });
            });
            
            const fragment = document.createDocumentFragment();
            let lastDateStr = null;
            
            for (let i = 0; i < 12; i++) {
                const position = (i * 100) / 11;
                const labelTime = new Date(startTime.getTime() + (totalDuration * i / 11));
                
                const labelDiv = document.createElement('div');
                labelDiv.className = 'heatmap-time-label';
                labelDiv.textContent = labelTime.toLocaleTimeString('fi-FI', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                }).replace('.', ':');
                
                Object.assign(labelDiv.style, {
                    left: `${position}%`,
                    transform: 'translateX(-50%)'
                });
                
                const segmentIndex = Math.floor((labelTime - startTime) / totalDuration * segmentCount);
                const activity = activityMap.get(segmentIndex);
                
                if (activity?.hasActivity) {
                    const level = activity.level;
                    labelDiv.classList.add(
                        level === 'extreme' ? 'high-activity' :
                        level === 'high' ? 'medium-activity' : 'low-activity'
                    );
                } else {
                    labelDiv.classList.add('no-activity');
                }
                
                fragment.appendChild(labelDiv);
                
                // Date change detection
                const currentDateStr = labelTime.toLocaleDateString('fi-FI');
                if (lastDateStr !== null && currentDateStr !== lastDateStr) {
                    const dateDiv = document.createElement('div');
                    dateDiv.className = 'heatmap-date-label';
                    
                    const dateParts = currentDateStr.split('.');
                    dateDiv.innerHTML = `${dateParts[1]}-${dateParts[0]}<br>${dateParts[2]}`;
                    
                    Object.assign(dateDiv.style, {
                        left: `${position}%`,
                        transform: 'translateX(-50%)'
                    });
                    
                    fragment.appendChild(dateDiv);
                }
                lastDateStr = currentDateStr;
            }
            
            container.appendChild(fragment);
        }

        function renderHeatmapStatistics() {
            console.log('DEBUG: renderHeatmapStatistics called');
            console.log('DEBUG: heatmapData exists?', !!heatmapData);
            console.log('DEBUG: heatmapData.statistics exists?', !!heatmapData?.statistics);
            
            if (!heatmapData?.statistics) {
                console.log('DEBUG: Early return - no statistics');
                return;
            }
            
            const statsContainer = document.getElementById('heatmapStats');
            console.log('DEBUG: statsContainer found?', !!statsContainer);
            
            if (!statsContainer) {
                console.log('DEBUG: Early return - no container');
                return;
            }
            
            console.log('DEBUG: Proceeding with rendering...');
            const stats = heatmapData.statistics;
            const totalEntries = heatmapData.total_entries;
            
            const statCards = [
                { value: totalEntries.toLocaleString(), label: 'Total Entries' },
                { value: heatmapData.duration_days, label: 'Days Span' },
                { value: stats.avg_hourly, label: 'Avg/Hour' },
                { value: stats.unique_entries || 0, label: 'Unique Entries' }
            ].map(card => 
                `<div class="stat-card">
                    <div class="stat-value">${card.value}</div>
                    <div class="stat-label">${card.label}</div>
                </div>`
            ).join('');
            
            const busiestHours = stats.busiest_hours.map(hour => 
                `<li><strong>${hour.formatted}</strong>: ${hour.count} entries</li>`
            ).join('');
            
            const topTypes = stats.top_types.map(type => 
                `<li><strong>${type.type}</strong>: ${type.count} (${type.percentage}%)</li>`
            ).join('');
            
            statsContainer.innerHTML = `
                <div class="heatmap-stat-grid">${statCards}</div>
                <div class="heatmap-details">
                    <div class="detail-section">
                        <h4>Busiest Hours</h4>
                        <ul class="busiest-list">${busiestHours}</ul>
                    </div>
                    <div class="detail-section">
                        <h4>Top Entry Values</h4>
                        <ul class="types-list">${topTypes}</ul>
                    </div>
                </div>
            `;
            
            console.log('DEBUG: statsContainer.innerHTML set to:', statsContainer.innerHTML.substring(0, 100) + '...');
        }



        function showFilteredModal(filteredData) {
            modalTitle.textContent = 'Filtered Entries';

            const storageKey = 'mermetro_excludedEntries_v1';
            let savedExcluded = null;
            try {
                const raw = localStorage.getItem(storageKey);
                if (raw) savedExcluded = JSON.parse(raw);
            } catch (e) {
                console.warn('Failed to read saved excluded entries', e);
            }

            const nodeListHtml = filteredData.length > 0 ? 
                filteredData.map(value => 
                    `<div class="checkbox-item">
                        <input type="checkbox" id="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}" 
                            class="entry-checkbox" value="${value}">
                        <label for="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}">${value}</label>
                    </div>`
                ).join('') : 'N/A';

            modalContent.innerHTML = `
                <div class="detail-section">
                    <p><strong>Total unique values:</strong> ${filteredData.length}</p>

                    <div style="margin:10px 0;">
                        <input id="newCommonValue" type="text" placeholder="Remove / Add value to common_values.txt" 
                               style="padding:6px; width:70%; margin-right:8px;">
                        <button id="addCommonButton" class="filter-button">Remove / Add common value</button>
                    </div>

                    <p><strong>Filtered Entries:</strong>
                        <span class="info-tooltip">
                            ?
                            <span class="tooltip-text">These values are either marked as filtered types or found in common_values.txt file. Checking entries will include them in the metromap logic (they can form or merge groups).</span>
                        </span>    
                    </p>
                    <div class="checkbox-container">
                        <button id="selectAllButton" class="filter-button">Select All</button>
                        <button id="deselectAllButton" class="filter-button">Deselect All</button>
                        <div class="checkbox-list">${nodeListHtml}</div>
                    </div>
                    <div class="reload-container">
                        <button id="reloadMapButton" class="reload-button">Process</button>
                    </div>
                </div>
            `;

            const checkboxList = modalContent.querySelector('.checkbox-list');

            checkboxList.onchange = function(e) {
                const cb = e.target;
                if (!cb || !cb.classList || !cb.classList.contains('entry-checkbox')) return;
                if (cb.checked) {
                    excludedEntries = excludedEntries.filter(item => item !== cb.value);
                } else {
                    if (!excludedEntries.includes(cb.value)) excludedEntries.push(cb.value);
                }
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };

            const selectAllBtn = document.getElementById('selectAllButton');
            const deselectAllBtn = document.getElementById('deselectAllButton');
            selectAllBtn.onclick = function() {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(checkbox => checkbox.checked = true);
                excludedEntries = [];
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };
            deselectAllBtn.onclick = function() {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(checkbox => checkbox.checked = false);
                excludedEntries = Array.from(checkboxList.querySelectorAll('.entry-checkbox')).map(cb => cb.value);
                try { localStorage.setItem(storageKey, JSON.stringify(excludedEntries)); } catch (err) {}
            };

            if (Array.isArray(savedExcluded)) {
                checkboxList.querySelectorAll('.entry-checkbox').forEach(cb => {
                    cb.checked = !savedExcluded.includes(cb.value);
                });
                excludedEntries = savedExcluded.slice();
            } else {
                deselectAllBtn.click();
            }

            function performReload() {
                const normalBtn = document.getElementById('reloadMapButton');
                const activeBtn = normalBtn;
                const originalText = activeBtn.textContent;
                activeBtn.textContent = 'Processing...';
                activeBtn.disabled = true;

                fetch('/api/v2/reload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify({ 
                        excludedEntries: excludedEntries
                    }),
                    cache: 'no-store'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        return updateMetromap().then(() => {
                            showRefreshNotification();
                        });
                    }
                    alert('Process failed');
                })
                .finally(() => {
                    activeBtn.textContent = originalText;
                    activeBtn.disabled = false;
                });
            }

            document.getElementById('reloadMapButton').onclick = function() { performReload(); };

            const addCommonBtn = document.getElementById('addCommonButton');
            addCommonBtn.onclick = async function() {
                const val = document.getElementById('newCommonValue').value.trim();
                if (!val) { alert('Enter a non-empty value.'); return; }
                if (val.length > 500 || val.includes('\n') || val.includes('\r')) { alert('Value too long or contains invalid characters.'); return; }

                let originalText = addCommonBtn.textContent;
                try {
                    const existing = await fetch('/api/v2/filtered-entries', { cache: 'no-store' }).then(r => r.json());
                    const willRemove = Array.isArray(existing) && existing.includes(val);

                    addCommonBtn.textContent = willRemove ? 'Removing...' : 'Adding...';
                    addCommonBtn.disabled = true;

                    const resp = await fetch('/api/v2/common/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ value: val })
                    }).then(r => r.json());

                    if (resp.success) {
                        if (resp.action === 'removed') alert('Removed from common_values.txt');
                        else if (resp.action === 'added') alert('Added to common_values.txt');
                        else alert('Updated common_values.txt');

                        const data = await fetch('/api/v2/filtered-entries', { cache: 'no-store' }).then(r => r.json());
                        checkboxList.innerHTML = data.map(value => 
                            `<div class="checkbox-item">
                                <input type="checkbox" id="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                    class="entry-checkbox" value="${value}">
                                <label for="entry_${value.replace(/[^a-zA-Z0-9]/g, '_')}">${value}</label>
                            </div>`
                        ).join('');
                        
                        try {
                            const raw = localStorage.getItem(storageKey);
                            if (raw) {
                                const currentSaved = JSON.parse(raw);
                                checkboxList.querySelectorAll('.entry-checkbox').forEach(cb => {
                                    cb.checked = !currentSaved.includes(cb.value);
                                });
                                excludedEntries = currentSaved.slice();
                            } else {
                                deselectAllBtn.click();
                            }
                        } catch (e) {
                            deselectAllBtn.click();
                        }
                    } else {
                        alert('Operation failed: ' + (resp.message || 'unknown'));
                    }
                } catch (err) {
                    console.error(err);
                    alert('Request failed');
                } finally {
                    addCommonBtn.textContent = originalText;
                    addCommonBtn.disabled = false;
                }
            };

            modal.style.display = 'block';
        }

        async function updateMetromap(ignoreTimeFilters = false) {
            try {
                const params = new URLSearchParams();
                params.append('t', Date.now());

                if (ignoreTimeFilters) {
                    params.append('reset', '1');
                } else {
                    const startDate = document.getElementById('startDate')?.value;
                    const startTime = document.getElementById('startTime')?.value;
                    const endDate = document.getElementById('endDate')?.value;
                    const endTime = document.getElementById('endTime')?.value;

                    if (startDate) {
                        const startDateTime = startTime ? `${startDate}T${startTime}` : `${startDate}T00:00:00`;
                        params.append('start', startDateTime);
                    }
                    if (endDate) {
                        const endDateTime = endTime ? `${endDate}T${endTime}` : `${endDate}T23:59:59`;
                        params.append('end', endDateTime);
                    }
                }

                const response = await fetch(`/api/v2/timestampfilter?${params.toString()}`);
                const data = await response.json();

                if (data.metromap !== currentMetromap) {
                    currentMetromap = data.metromap;
                    const container = document.getElementById('metromap-container');
                    container.innerHTML = `<div class="mermaid">${currentMetromap}</div>`;

                    await mermaid.run({ querySelector: '#metromap-container .mermaid' });
                    setTimeout(addClickEvents, 100);
                    const ts = document.getElementById('timestamp');
                    if (ts) ts.textContent = data.timestamp;
                }
            } catch (error) {
                console.error('Update error:', error);
            }
        }

        function showRefreshNotification() {
            const notification = document.createElement('div');
            notification.id = 'refreshNotification';
            notification.className = 'refresh-notification';
            notification.innerHTML = `
                <div class="refresh-notification-content">
                    <h3>Metromap Updated Successfully!</h3>
                    <strong>Please refresh the page to see the updated groups and timeline.</strong></p>
                    <div class="refresh-buttons">
                        <button id="refreshPageButton" class="refresh-page-button">Refresh Page Now</button>
                        <button id="dismissButton" class="dismiss-button">Dismiss</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            document.getElementById('refreshPageButton').addEventListener('click', function() {
                location.reload();
            });
            
            document.getElementById('dismissButton').addEventListener('click', function() {
                notification.remove();
            });
        }
        
        function showModal(title, content) {
            modalTitle.textContent = title;
            modalContent.innerHTML = content;
            modal.style.display = 'block';
        }

        document.addEventListener('DOMContentLoaded', function() {
            modal = document.getElementById('nodeModal');
            modalTitle = document.getElementById('modalTitle');
            modalContent = document.getElementById('modalContent');
            
            const directionBtn = document.getElementById('direction-btn');
            directionBtn.addEventListener('click', function() {
                chartDirection = (chartDirection === 'TD') ? 'LR' : 'TD';
                directionBtn.textContent = (chartDirection === 'TD') ? 'Top Down' : 'Left Right';
                updateTimelineWithDirection();
            });

            const groupLogModal = document.getElementById('groupLogModal');
            
            document.querySelector('#nodeModal .close').addEventListener('click', () => modal.style.display = 'none');
            document.querySelector('#groupLogModal .close').addEventListener('click', () => groupLogModal.style.display = 'none');
            
            window.addEventListener('click', function(event) {
                if (event.target === modal) modal.style.display = 'none';
                if (event.target === groupLogModal) groupLogModal.style.display = 'none';
            });

            document.getElementById('filteredButton').addEventListener('click', function() {
                fetch('/api/v2/filtered-entries')
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            showFilteredModal(data);
                        }
                    })
                    .catch(error => console.error('Error:', error));
            });

            const applyBtn = document.getElementById('applyTimeRangeButton');
            const clearBtn = document.getElementById('clearTimeRangeButton');
            if (applyBtn) {
                applyBtn.addEventListener('click', function() {
                    const startDate = document.getElementById('startDate').value;
                    const startTime = document.getElementById('startTime').value;
                    const endDate = document.getElementById('endDate').value;
                    const endTime = document.getElementById('endTime').value;

                    if (startDate && endDate) {
                        const startDateTime = `${startDate}T${startTime || '00:00:00'}`;
                        const endDateTime = `${endDate}T${endTime || '23:59:59'}`;

                        if (startDateTime > endDateTime) {
                            alert('Start time must be before end time');
                            return;
                        }
                    }

                    applyBtn.textContent = 'Reloading...';
                    applyBtn.disabled = true;

                    updateMetromap().finally(() => {
                        applyBtn.textContent = 'Apply Time Range';
                        applyBtn.disabled = false;
                        showRefreshNotification();
                    });
                });
            }
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    clearBtn.textContent = 'Resetting...';
                    clearBtn.disabled = true;

                    document.getElementById('startDate').value = '';
                    document.getElementById('startTime').value = '00:00:00';
                    document.getElementById('endDate').value = '';
                    document.getElementById('endTime').value = '23:59:59';

                    updateMetromap(true).finally(() => {
                        clearBtn.textContent = 'Reset';
                        clearBtn.disabled = false;
                        showRefreshNotification();
                    });
                });
            }

            loadGroups();
            if (selectedGroup) updateTimeline();

            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.addedNodes.length && document.querySelector('.mermaid svg')) {
                        addClickEvents();
                        addGroupClickEvents();
                        observer.disconnect();
                    }
                });
            });
            observer.observe(document.querySelector('.mermaid'), { childList: true, subtree: true });
            
            setTimeout(() => {
                addClickEvents();
                addGroupClickEvents();
            }, 2000);

            const startDateEl = document.getElementById('startDate');
            const endDateEl = document.getElementById('endDate');
            if ((startDateEl && startDateEl.value) || (endDateEl && endDateEl.value)) {
                console.log('skip');
            } else {
                updateMetromap();
            }
         });

        setInterval(updateTimeline, 30000);

        async function showHeatmapSegmentEntries(startTime, endTime) {
            try {
                showModal("Loading entries...", "<div style='text-align:center;padding:20px;'>Loading entries for selected time range...</div>");
                
                const groupParam = selectedGroup ? selectedGroup : 'all';
                const url = `/api/v2/heatmap-entries/${groupParam}?start=${startTime}&end=${endTime}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load entries');
                }
                
                const startDisplay = new Date(startTime).toLocaleString();
                const endDisplay = new Date(endTime).toLocaleString();
                const title = `${data.count} Entries (${startDisplay} - ${endDisplay})`;
                
                let content = `
                    <p><strong>Activity Level:</strong> ${data.count > 75 ? 'High' : (data.count > 25 ? 'Medium' : 'Low')}</p>
                    <p><strong>Group:</strong> ${selectedGroup || 'All entries'}</p>
                    
                    <div class="entries-section">
                        <h4>Time Range Entries <span class="tooltip" title="All log entries that occurred during this time period">ℹ</span></h4>
                        <table class="entries-table">
                            <thead><tr><th>Line</th><th>Timestamp</th><th>Type</th><th>Value</th></tr></thead>
                            <tbody>`;
                            
                data.entries.forEach(entry => {
                    content += `<tr>
                        <td>${entry.line || 'N/A'}</td>
                        <td>${entry.timestamp || 'N/A'}</td>
                        <td>${entry.type || 'N/A'}</td>
                        <td class="value-cell" title="${entry.value || ''}">${entry.value || 'N/A'}</td>
                    </tr>`;
                });
                            
                content += `</tbody>
                        </table>
                    </div>`;
                
                showModal(title, content);
                
            } catch (error) {
                console.error('Error loading heatmap segment entries:', error);
                showModal('Error', `<p>Failed to load entries: ${error.message}</p>`);
            }
        }
    </script>
    <style>
        .timeline-heatmap-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }

        .heatmap-bar {
            height: 60px;
            background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            border-radius: 8px;
            position: relative;
            margin: 35px 0 15px 0; 
            overflow: visible;
            user-select: none;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .heatmap-segment {
            position: absolute;
            top: 0;
            bottom: 0;
            transition: all 0.2s ease;
            border-right: 1px solid rgba(255,255,255,0.2);
            cursor: default;
        }

        .heatmap-segment:hover {
            transform: scaleY(1.1);
            z-index: 10;
            filter: brightness(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .heatmap-time-label {
            position: absolute;
            top: -25px;
            font-size: 11px;
            font-weight: 500;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
            white-space: nowrap;
            z-index: 20;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .heatmap-time-label.high-activity {
            font-weight: bold;
            background: rgba(229, 115, 115, 0.9);
            color: white;
            border-color: #e57373;
        }

        .heatmap-time-label.medium-activity {
            font-weight: 600;
            background: rgba(255, 183, 77, 0.9);
            color: #333;
            border-color: #ffb74d;
        }

        .heatmap-time-label.low-activity {
            font-weight: 500;
            background: rgba(129, 199, 132, 0.9);
            color: #333;
            border-color: #81c784;
        }

        .heatmap-time-label.no-activity {
            font-weight: normal;
            background: rgba(224, 224, 224, 0.9);
            color: #666;
            border-color: #e0e0e0;
        }

        .heatmap-date-label {
            position: absolute;
            bottom: -20px;
            font-size: 10px;
            font-weight: bold;
            color: #666;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #aaa;
            white-space: nowrap;
            z-index: 15;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .heatmap-info {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .heatmap-range {
            text-align: center;
            font-size: 14px;
            color: #495057;
        }



        .heatmap-stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(33, 150, 243, 0.3);
            transition: transform 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .stat-card .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-card .stat-label {
            font-size: 12px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .heatmap-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .detail-section h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 5px;
        }

        .busiest-list, .types-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .busiest-list li, .types-list li {
            padding: 8px 12px;
            margin: 5px 0;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #2196F3;
            font-size: 14px;
        }

        .busiest-list li strong, .types-list li strong {
            color: #1976D2;
        }

        .heatmap-error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #dc3545;
            font-weight: 500;
            background-color: #f8d7da;
            border-radius: 6px;
            padding: 20px;
        }

        @media (max-width: 768px) {
            .heatmap-details {
                grid-template-columns: 1fr;
            }
            
            .heatmap-stat-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .header { background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .status { color: #4CAF50; font-weight: bold; }
        .mermaid { text-align: center; background-color: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-height: 400px; }
        #nodes-container { background-color: transparent; padding: 0; border-radius: 0; box-shadow: none; margin-top: 20px; min-height: 0; }
        #nodes-container .section-header { margin-bottom: 15px; }
        .diagram-section { margin-bottom: 30px; }
        h1 { color: #333; text-align: center; margin: 0 0 20px 0; }
        .controls { background-color: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; }
        .control-group { margin-bottom: 10px; }
        .control-group label { display: inline-block; width: 120px; font-weight: bold; }
        #group-selector { padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 300px; }
        #filteredButton { padding: 8px 16px; color: white; border: none; border-radius: 5px; font-size: 14px; cursor: pointer; font-family: inherit; font-weight: bold; background-color: #FF9800; margin-left: auto; }
        #filteredButton:hover { background-color: #F57C00; opacity: 0.9; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: none; width: 90%; max-width: 800px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-height: 80vh; overflow-y: auto; font-family: inherit; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover, .close:focus { color: black; text-decoration: none; }
        .entries-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .entries-table th, .entries-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .entries-table th { background-color: #2196F3; color: white; font-weight: bold; }
        .entries-table.filtered th { background-color: #FF9800; color: white; }
        .entries-table td:first-child, .entries-table td:nth-child(2) { text-align: center; font-weight: bold; color: #1976D2; }
        .filtered-section { margin-top: 20px; padding-top: 15px; border-top: 2px solid #FF9800; }
        .filtered-table td:first-child, .filtered-table td:nth-child(2) { text-align: center; font-weight: bold; color: #F57C00; }
        .entries-table tr:nth-child(even) { background-color: #f9f9f9; }
        .value-cell { max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-container { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; }
        .entries-section { margin-bottom: 20px; }
        .entries-section h4 { color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px; margin-top: 0; }
        .node-info { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-bottom: 2px solid #2196F3; }
        .node-info p { margin: 5px 0; }
        .merge-log { background-color: #fff3cd; padding: 15px; border-radius: 5px; border: 1px solid #ffeaa7; }
        .merge-entry { background-color: white; padding: 10px; margin: 5px 0; border-radius: 3px; border-left: 3px solid #f39c12; font-family: monospace; font-size: 12px; white-space: pre-wrap; }
        .tooltip { cursor: help; color: #1976D2; }
        .node { cursor: pointer; transition: opacity 0.2s; }
        .node:hover { opacity: 0.8; }
        #direction-btn { padding: 6px 18px; font-size: 15px; border: 1px solid #2196f3; background: #fff; color: #2196f3; border-radius: 5px; cursor: pointer; font-weight: bold; margin-left: 10px; }
        #direction-btn:hover { background: #e3f2fd; }
        .group-section { margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border-left: 3px solid #2196F3; }
        .entry-list { margin: 8px 0; padding-left: 0; list-style: none; }
        .entry-list li { margin: 4px 0; padding: 2px 0; font-family: monospace; font-size: 13px; word-break: break-all; overflow-wrap: anywhere; }
        .entry-type { color: #666; font-size: 11px; font-style: italic; }
        .no-entries { color: #999; font-style: italic; margin: 5px 0; }
        .detail-section { margin-bottom: 20px; }
        .detail-section h4 { color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px; margin-top: 0; }
        .detail-section p { color: #333; font-weight: normal; word-wrap: break-word; overflow-wrap: break-word; }
        .info-tooltip { position: relative; display: inline-block; background-color: #2196F3; color: white; border-radius: 50%; width: 16px; height: 16px; text-align: center; font-size: 12px; font-weight: bold; line-height: 16px; cursor: help; margin-left: 5px; vertical-align: top; }
        .info-tooltip:hover { background-color: #1976D2; }
        .tooltip-text { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1001; bottom: 125%; left: 50%; margin-left: -125px; font-size: 13px; font-weight: normal; line-height: 1.3; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .tooltip-text::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #333 transparent transparent transparent; }
        .info-tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
        .checkbox-container { margin-top: 15px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background-color: #f9f9f9; }
        .checkbox-list { margin-top: 10px; border-top: 1px solid #ddd; padding-top: 10px; }
        .checkbox-item { margin: 5px 0; display: flex; align-items: center; }
        .checkbox-item input { margin-right: 8px; cursor: pointer; }
        .checkbox-item label { cursor: pointer; word-break: break-all; }
        .filter-button { background-color: #607D8B; color: white; border: none; padding: 5px 10px; border-radius: 4px; margin-right: 10px; cursor: pointer; font-size: 12px; }
        .filter-button:hover { background-color: #455A64; }
        .reload-container { margin-top: 20px; text-align: center; }
        .reload-button { background-color: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; transition: background-color 0.3s; }
        .reload-button:hover { background-color: #388E3C; }
        .reload-button:disabled { background-color: #A5D6A7; cursor: not-allowed; }
        .timerange-container { margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding: 10px; background-color: #f9f9f9; border-radius: 5px; border: 1px solid #ddd; }
        .timerange-container label { font-weight: bold; color: #333; font-size: 14px; }
        .timerange-container input[type="date"], .timerange-container input[type="time"] { padding: 6px 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 14px; font-family: inherit; background-color: white; }
        .timerange-container input[type="date"]:focus, .timerange-container input[type="time"]:focus { outline: none; border-color: #2196F3; }
        .timerange-container button { padding: 8px 16px; color: white; border: none; border-radius: 5px; font-size: 14px; cursor: pointer; font-family: inherit; font-weight: bold; }
        #applyTimeRangeButton { background-color: #4CAF50; }
        #applyTimeRangeButton:hover { background-color: #388E3C; }
        #clearTimeRangeButton { background-color: #757575; }
        #clearTimeRangeButton:hover { background-color: #424242; }
        .refresh-notification { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 2000; display: flex; align-items: center; justify-content: center; }
        .refresh-notification-content { background-color: white; padding: 30px; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); text-align: center; max-width: 500px; margin: 20px; animation: slideIn 0.3s ease-out; }
        .refresh-notification-content h3 { color: #4CAF50; margin: 0 0 15px 0; font-size: 20px; }
        .refresh-notification-content p { color: #333; margin: 0 0 20px 0; line-height: 1.5; }
        .refresh-buttons { display: flex; gap: 15px; justify-content: center; }
        .refresh-page-button { background-color: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        .refresh-page-button:hover { background-color: #388E3C; }
        .dismiss-button { background-color: #757575; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        .dismiss-button:hover { background-color: #616161; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-50px); } to { opacity: 1; transform: translateY(0); } }

    </style>
</head>
<body>
    <div class="header"><h1>Mermetro2</h1></div>
    <div class="controls">
        <div class="control-group">
            <label for="group-selector">Select Group:</label>
            <select id="group-selector"></select>
        </div>
        <div class="control-group">
            <label>Selected:</label>
            <span id="selected-group" class="status">{{ selected_group or 'None' }}</span>
        </div>
        <div class="control-group">
            <label>Last Update:</label>
            <span id="timestamp" class="status">{{ timestamp }}</span>
        </div>
        <button id="filteredButton">Filtered Entries</button>
    </div>

    <div class="timerange-container">
        <input type="date" id="startDate" placeholder="yyyy-mm-dd">
        <label for="startTime">Time:</label>
        <input type="time" id="startTime" value="00:00:00" step="1">

        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" placeholder="yyyy-mm-dd">
        <label for="endTime">Time:</label>
        <input type="time" id="endTime" value="23:59:59" step="1">

        <button id="applyTimeRangeButton">Apply Time Range</button>
        <button id="clearTimeRangeButton">Reset</button>
    </div>



    <div class="diagram-section">
        <div class="section-header">
            <h2>Group Formation Timeline</h2>
            <div class="control-group">
                <label for="direction-btn" style="margin-right:10px;">Swap Direction</label>
                <button id="direction-btn" type="button">Top Down</button>
            </div>
        </div>
        <div class="diagram-container" id="formation-timeline-container">
            {% if timeline %}
            <div class="mermaid">{{ timeline|safe }}</div>
            {% else %}
            <div class="mermaid"></div>
            {% endif %}
        </div>
    </div>
    <div class="diagram-section">
        <div class="section-header">
            <h2>Node Relationships</h2>
        </div>
        <div class="diagram-container" id="nodes-container">
            <div class="mermaid" id="nodes-mermaid"></div>
        </div>
    </div>
    
    <div class="diagram-section">
        <div class="section-header">
            <h2>Activity Timeline Heatmap</h2>
        </div>
        <div class="timeline-heatmap-container">
            <div class="heatmap-bar" id="timelineHeatmapBar">
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-style: italic;">
                    Loading heatmap data...
                </div>
            </div>
            <div class="heatmap-info">
                <div class="heatmap-range">
                    <strong>Time Range:</strong><br>
                    <span id="heatmapStart">Loading...</span> to <span id="heatmapEnd">Loading...</span>
                </div>
            </div>
            <div id="heatmapStats">
            </div>
        </div>
    </div>
    <div id="nodeModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="modalTitle">Details</h2>
            <div id="modalContent"></div>
        </div>
    </div>
    <div id="groupLogModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="document.getElementById('groupLogModal').style.display='none'">&times;</span>
            <h2 id="groupLogModalTitle">Group Formation Log</h2>
            <div id="groupLogModalContent"></div>
        </div>
    </div>
</body>
</html>
